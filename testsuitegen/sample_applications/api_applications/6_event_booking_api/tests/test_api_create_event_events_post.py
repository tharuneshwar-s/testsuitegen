import pytest
import requests
import uuid
import re

BASE_URL = "http://localhost:8006"
ENDPOINT = "/events"
METHOD = "POST"

# Operation: create_event_events_post
# Error Codes Expected: 422
# Auto-generated by TestSuiteGen - Fixtures are pre-compiled


@pytest.fixture(scope="module")
def api_client():
    """Provides a configured API client for testing."""
    session = requests.Session()
    session.headers.update({"Content-Type": "application/json"})
    yield session
    session.close()


@pytest.fixture(scope="module")
def test_data_setup(api_client):
    """No prerequisite resources needed for this test."""
    yield {"created_resources": [], "placeholders": {}}


@pytest.mark.parametrize(
    "intent, payload, path_params, expected_status",
    [
        pytest.param(
            "HAPPY_PATH",
            {
                "capacity": 10,
                "code": "CONF-20241120",
                "event_type": "conference",
                "price": 0.0,
                "title": "Conference Event",
            },
            {},
            201,
            id="HAPPY_PATH",
        ),
        pytest.param(
            "TYPE_VIOLATION",
            {
                "capacity": 10,
                "code": "CONF-20241120",
                "event_type": "__INVALID_TYPE__",
                "price": 0.0,
                "title": "Conference Event",
            },
            {},
            422,
            id="TYPE_VIOLATION",
        ),
        pytest.param(
            "TYPE_VIOLATION",
            {
                "capacity": "__INVALID_TYPE__",
                "code": "CONF-20241120",
                "event_type": "conference",
                "price": 0.0,
                "title": "Conference Event",
            },
            {},
            422,
            id="TYPE_VIOLATION",
        ),
        pytest.param(
            "BOUNDARY_MIN_MINUS_ONE",
            {
                "capacity": 9,
                "code": "CONF-20241120",
                "event_type": "conference",
                "price": 0.0,
                "title": "Conference Event",
            },
            {},
            422,
            id="BOUNDARY_MIN_MINUS_ONE",
        ),
        pytest.param(
            "BOUNDARY_MAX_PLUS_ONE",
            {
                "capacity": 1001,
                "code": "CONF-20241120",
                "event_type": "conference",
                "price": 0.0,
                "title": "Conference Event",
            },
            {},
            422,
            id="BOUNDARY_MAX_PLUS_ONE",
        ),
        pytest.param(
            "TYPE_VIOLATION",
            {
                "capacity": 10,
                "code": "CONF-20241120",
                "event_type": "conference",
                "price": "__INVALID_TYPE__",
                "title": "Conference Event",
            },
            {},
            422,
            id="TYPE_VIOLATION",
        ),
        pytest.param(
            "BOUNDARY_MIN_MINUS_ONE",
            {
                "capacity": 10,
                "code": "CONF-20241120",
                "event_type": "conference",
                "price": -0.01,
                "title": "Conference Event",
            },
            {},
            422,
            id="BOUNDARY_MIN_MINUS_ONE",
        ),
        pytest.param(
            "BOUNDARY_MAX_PLUS_ONE",
            {
                "capacity": 10,
                "code": "CONF-20241120",
                "event_type": "conference",
                "price": 1000.0,
                "title": "Conference Event",
            },
            {},
            422,
            id="BOUNDARY_MAX_PLUS_ONE",
        ),
        pytest.param(
            "NOT_MULTIPLE_OF",
            {
                "capacity": 10,
                "code": "CONF-20241120",
                "event_type": "conference",
                "price": 7.999,
                "title": "Conference Event",
            },
            {},
            422,
            id="NOT_MULTIPLE_OF",
        ),
    ],
)
def test_create_event_events_post_contract(
    api_client, test_data_setup, intent, payload, path_params, expected_status
):
    """
    Validates POST /events against the OpenAPI contract.
    Intent: {intent}
    Expected Status: {expected_status}


    Error Response Information:
    - Status 422: Validation Error
      Response Schema: object with properties: detail

    """
    url = f"{BASE_URL}{ENDPOINT}"
    created_resources = test_data_setup.get("created_resources", [])

    # No placeholder resolution needed for this operation
    if path_params is None:
        path_params = {}
    if not isinstance(path_params, dict):
        path_params = dict(path_params)

    # Replace path parameters in URL
    for param_name in re.findall(r"\{(\w+)\}", url):
        param_value = path_params.get(param_name)
        # Handle INVALID_TYPE for path parameters
        if param_value == "__INVALID_TYPE__":
            param_value = "invalid_string_value"
        # Fallback to a dummy value if still None
        if param_value is None:
            param_value = 1
        url = url.replace(f"{{{param_name}}}", str(param_value))

    # Extract query parameters from payload
    query_params = {}
    if payload and METHOD in ("GET", "DELETE"):
        # For GET/DELETE, move payload to query params
        query_params = payload.copy()
        payload = None

    # Generate unique data for creation tests to avoid conflicts
    if METHOD in ("POST", "PUT", "PATCH") and payload and intent == "HAPPY_PATH":
        if "username" in payload:
            payload["username"] = f"{payload['username']}_{uuid.uuid4().hex[:8]}"
        if "email" in payload:
            email_val = payload["email"]
            if "@" in str(email_val):
                email_parts = email_val.split("@")
                payload["email"] = (
                    f"{email_parts[0][:10]}_{uuid.uuid4().hex[:6]}@{email_parts[1]}"
                )

    response = api_client.request(
        method=METHOD,
        url=url,
        json=payload if payload else None,
        params=query_params if query_params else None,
        headers={"Content-Type": "application/json"},
    )

    assert (
        response.status_code == expected_status
    ), f"Failed Intent: {intent}. Expected {expected_status}, got {response.status_code}. Body: {response.text}"

    # Store created resource for cleanup if this is a creation test
    if response.status_code in (200, 201) and METHOD == "POST":
        try:
            resource_data = response.json()
            if isinstance(resource_data, dict):
                res_id = resource_data.get("id")
                if res_id:
                    # Append to the list defined in the fixture (lists are mutable)
                    created_resources.append(
                        {
                            "type": "test_resource",
                            "id": res_id,
                            "endpoint": f"{url}/{res_id}",
                        }
                    )
        except Exception:
            pass

    # Validate error response structure if applicable
    if expected_status >= 400 and response.content:
        try:
            error_body = response.json()
            assert error_body is not None, "Error response should have a JSON body"
            # Additional validation can be added here based on error schema
        except ValueError:
            # Some error responses might not have JSON body
            pass
