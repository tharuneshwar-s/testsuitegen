import pytest
import requests
import uuid
import re

BASE_URL = "http://localhost:8006"
ENDPOINT = "/events"
METHOD = "GET"

# Operation: list_events_events_get
# Error Codes Expected: 
# Auto-generated by TestSuiteGen - Fixtures are pre-compiled


@pytest.fixture(scope="module")
def api_client():
    '''Provides a configured API client for testing.'''
    session = requests.Session()
    session.headers.update({"Content-Type": "application/json"})
    yield session
    session.close()


@pytest.fixture(scope="module")
def test_data_setup(api_client):
    """No prerequisite resources needed for this test."""
    yield {"created_resources": [], "placeholders": {}}


@pytest.mark.parametrize("intent, payload, path_params, expected_status", [
    pytest.param(
        "HAPPY_PATH",
        {},
        {},
        200,
        id="HAPPY_PATH"
    ),
])
def test_list_events_events_get_contract(api_client, test_data_setup, intent, payload, path_params, expected_status):    
    """
    Validates GET /events against the OpenAPI contract.
    Intent: {intent}
    Expected Status: {expected_status}
    
    
    """
    url = f"{BASE_URL}{ENDPOINT}"
    created_resources = test_data_setup.get("created_resources", [])

    # No placeholder resolution needed for this operation
    if path_params is None:
        path_params = {}
    if not isinstance(path_params, dict):
        path_params = dict(path_params)

    # Replace path parameters in URL
    for param_name in re.findall(r'\{(\w+)\}', url):
        param_value = path_params.get(param_name)
        # Handle INVALID_TYPE for path parameters
        if param_value == "__INVALID_TYPE__":
            param_value = "invalid_string_value"
        # Fallback to a dummy value if still None
        if param_value is None:
            param_value = 1
        url = url.replace(f"{{{param_name}}}", str(param_value))
    
    # Extract query parameters from payload
    query_params = {}
    if payload and METHOD in ("GET", "DELETE"):
        # For GET/DELETE, move payload to query params
        query_params = payload.copy()
        payload = None
    
    # Generate unique data for creation tests to avoid conflicts
    if METHOD in ("POST", "PUT", "PATCH") and payload and intent == "HAPPY_PATH":
        if "username" in payload:
            payload["username"] = f"{payload['username']}_{uuid.uuid4().hex[:8]}"
        if "email" in payload:
            email_val = payload["email"]
            if "@" in str(email_val):
                email_parts = email_val.split("@")
                payload["email"] = f"{email_parts[0][:10]}_{uuid.uuid4().hex[:6]}@{email_parts[1]}"
    
    
    response = api_client.request(
        method=METHOD,
        url=url,
        json=payload if payload else None,
        params=query_params if query_params else None,
        headers={"Content-Type": "application/json"}
    )
    
    assert response.status_code == expected_status,         f"Failed Intent: {intent}. Expected {expected_status}, got {response.status_code}. Body: {response.text}"
    
    # Store created resource for cleanup if this is a creation test
    if response.status_code in (200, 201) and METHOD == "POST":
        try:
            resource_data = response.json()
            if isinstance(resource_data, dict):
                res_id = resource_data.get("id")
                if res_id:
                    # Append to the list defined in the fixture (lists are mutable)
                    created_resources.append({
                        "type": "test_resource",
                        "id": res_id,
                        "endpoint": f"{url}/{res_id}"
                    })
        except Exception:
            pass
    
    
    # Validate error response structure if applicable
    if expected_status >= 400 and response.content:
        try:
            error_body = response.json()
            assert error_body is not None, "Error response should have a JSON body"
            # Additional validation can be added here based on error schema
        except ValueError:
            # Some error responses might not have JSON body
            pass