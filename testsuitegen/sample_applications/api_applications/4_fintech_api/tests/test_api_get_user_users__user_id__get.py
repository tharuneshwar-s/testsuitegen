import pytest
import requests
import uuid
import re

BASE_URL = "http://localhost:8004"
ENDPOINT = "/users/{user_id}"
METHOD = "GET"

# Operation: get_user_users__user_id__get
# Error Codes Expected: 422
# Auto-generated by TestSuiteGen - Fixtures are pre-compiled


@pytest.fixture(scope="module")
def api_client():
    """Provides a configured API client for testing."""
    session = requests.Session()
    session.headers.update({"Content-Type": "application/json"})
    yield session
    session.close()


@pytest.fixture(scope="module")
def test_data_setup(api_client):
    """
    Setup fixture that creates prerequisite test resources.
    Auto-generated by TestSuiteGen - DO NOT EDIT MANUALLY.
    """
    created_resources = []
    placeholders = {}

    # Create user resource
    created_user_payload = {
        "name": "Alice Smith",
        "email": "alicesmith@domain.com",
        "account_id": 10000,
    }

    # Make unique to avoid conflicts on repeated runs
    import uuid as _uuid

    _unique_suffix = _uuid.uuid4().hex[:8]
    for _key in created_user_payload:
        if isinstance(created_user_payload[_key], str):
            if "email" in _key.lower():
                parts = created_user_payload[_key].split("@")
                if len(parts) == 2:
                    created_user_payload[_key] = (
                        f"{parts[0]}_{_unique_suffix}@{parts[1]}"
                    )
            elif "name" in _key.lower():
                created_user_payload[_key] = (
                    f"{created_user_payload[_key]}_{_unique_suffix}"
                )

    created_user_response = api_client.post(
        f"{BASE_URL}/users", json=created_user_payload
    )

    if created_user_response.status_code in (200, 201):
        created_user_data = created_user_response.json()
        created_user_id = created_user_data.get("id")
        if created_user_id:
            created_resources.append(
                {
                    "type": "user",
                    "id": created_user_id,
                    "data": created_user_data,
                    "endpoint": f"{BASE_URL}/users/{created_user_id}",
                }
            )
            # Map placeholder to created ID
            placeholders["USE_CREATED_RESOURCE"] = created_user_id
            placeholders["USE_CREATED_RESOURCE_USER"] = created_user_id
    else:
        # Creation failed - tests needing this resource will be skipped
        print(
            f"Warning: Could not create user: {created_user_response.status_code} - {created_user_response.text}"
        )

    yield {
        "created_resources": created_resources,
        "placeholders": placeholders,
    }

    # Teardown: Clean up created resources in reverse order
    for resource in reversed(created_resources):
        try:
            delete_response = api_client.delete(resource["endpoint"])
            if delete_response.status_code not in (200, 204, 404):
                print(
                    f"Cleanup warning: {delete_response.status_code} deleting {resource['type']} {resource['id']}"
                )
        except Exception as e:
            print(
                f"Cleanup error: Could not delete {resource['type']} {resource['id']}: {e}"
            )


@pytest.mark.parametrize(
    "intent, payload, path_params, expected_status",
    [
        pytest.param(
            "HAPPY_PATH", {}, {"user_id": "USE_CREATED_RESOURCE"}, 200, id="HAPPY_PATH"
        ),
        pytest.param(
            "RESOURCE_NOT_FOUND",
            {},
            {"user_id": "nonexistent_resource"},
            404,
            id="RESOURCE_NOT_FOUND",
        ),
    ],
)
def test_get_user_users__user_id__get_contract(
    api_client, test_data_setup, intent, payload, path_params, expected_status
):
    """
    Validates GET /users/{user_id} against the OpenAPI contract.
    Intent: {intent}
    Expected Status: {expected_status}


    Error Response Information:
    - Status 422: Validation Error
      Response Schema: object with properties: detail

    """
    url = f"{BASE_URL}{ENDPOINT}"
    created_resources = test_data_setup.get("created_resources", [])

    # Resolve USE_CREATED_RESOURCE placeholders to actual IDs
    placeholders = test_data_setup.get("placeholders", {})
    if path_params is None:
        path_params = {}
    if not isinstance(path_params, dict):
        path_params = dict(path_params)

    for param_key, param_val in list(path_params.items()):
        if isinstance(param_val, str) and param_val.startswith("USE_CREATED_RESOURCE"):
            resolved_id = placeholders.get(param_val)
            if resolved_id is None and test_data_setup.get("created_resources"):
                resolved_id = test_data_setup["created_resources"][0].get("id")
            if resolved_id is None:
                pytest.skip(
                    f"Required resource placeholder '{param_val}' was not resolved - resource creation may have failed"
                )
            path_params[param_key] = resolved_id

    # Replace path parameters in URL
    for param_name in re.findall(r"\{(\w+)\}", url):
        param_value = path_params.get(param_name)
        # Handle INVALID_TYPE for path parameters
        if param_value == "__INVALID_TYPE__":
            param_value = "invalid_string_value"
        # Fallback to a dummy value if still None
        if param_value is None:
            param_value = 1
        url = url.replace(f"{{{param_name}}}", str(param_value))

    # Extract query parameters from payload
    query_params = {}
    if payload and METHOD in ("GET", "DELETE"):
        # For GET/DELETE, move payload to query params
        query_params = payload.copy()
        payload = None

    # Generate unique data for creation tests to avoid conflicts
    if METHOD in ("POST", "PUT", "PATCH") and payload and intent == "HAPPY_PATH":
        if "username" in payload:
            payload["username"] = f"{payload['username']}_{uuid.uuid4().hex[:8]}"
        if "email" in payload:
            email_parts = payload["email"].split("@")
            payload["email"] = (
                f"{email_parts[0]}_{uuid.uuid4().hex[:8]}@{email_parts[1]}"
            )

    response = api_client.request(
        method=METHOD,
        url=url,
        json=payload if payload else None,
        params=query_params if query_params else None,
        headers={"Content-Type": "application/json"},
    )

    assert (
        response.status_code == expected_status
    ), f"Failed Intent: {intent}. Expected {expected_status}, got {response.status_code}. Body: {response.text}"

    # Store created resource for cleanup if this is a creation test
    if response.status_code in (200, 201) and METHOD == "POST":
        try:
            resource_data = response.json()
            if isinstance(resource_data, dict):
                res_id = resource_data.get("id")
                if res_id:
                    # Append to the list defined in the fixture (lists are mutable)
                    created_resources.append(
                        {
                            "type": "test_resource",
                            "id": res_id,
                            "endpoint": f"{url}/{res_id}",
                        }
                    )
        except Exception:
            pass

    # Validate error response structure if applicable
    if expected_status >= 400 and response.content:
        try:
            error_body = response.json()
            assert error_body is not None, "Error response should have a JSON body"
            # Additional validation can be added here based on error schema
        except ValueError:
            # Some error responses might not have JSON body
            pass
