# suite_gen/templates.py
# Jinja2 Templates for Test Suite Generation

# Template for testing raw Python functions (Unit Tests)
UNIT_TEST_TEMPLATE = """
import pytest
from {{ module_path }} import {{ function_name }}{% if enum_types %}, {{ enum_types | join(', ') }}{% endif %}

# Auto-generated by TestSuiteGen
# Operation: {{ operation_id }}
{% if enum_types %}
# Enum mapping for automatic conversion
_ENUM_MAP = {
{%- for enum_type in enum_types %}
    "{{ enum_type }}": {{ enum_type }},
{%- endfor %}
}
{% endif %}

class Test{{ operation_id | replace('_', '') }}:

    @pytest.mark.parametrize("intent, kwargs, expected_status", [
    {%- for case in test_cases %}
        pytest.param(
            "{{ case.intent }}",
            {{ case.payload_formatted }},
            {{ case.expected_status }},
            id="{{ case.intent }}"
        ),
    {%- endfor %}
    ])
    def test_{{ operation_id }}_contract(self, intent, kwargs, expected_status):
        \"\"\"
        Contract testing for {{ function_name }}.
        Intent: {intent}
        Expected: {expected_status} (400/422 = Exception)
        \"\"\"
        {%- if enum_conversions %}
        
        # Convert enum string values to actual enum instances for HAPPY_PATH
        if expected_status < 400:
        {%- for param, enum_type in enum_conversions.items() %}
            if "{{ param }}" in kwargs and isinstance(kwargs["{{ param }}"], str):
                try:
                    kwargs["{{ param }}"] = {{ enum_type }}(kwargs["{{ param }}"].lower())
                except ValueError:
                    pass  # Let the test fail with invalid enum value
        {%- endfor %}
        {%- endif %}
        
        # Negative Tests (Expect Exceptions)
        if expected_status >= 400:
            # We expect TypeError for structural issues, ValueError for constraints, or AttributeError for None access
            with pytest.raises((ValueError, TypeError, AssertionError, AttributeError)):
                {{ function_name }}(**kwargs)
        
        # Happy Path (Expect Return Value)
        else:
            result = {{ function_name }}(**kwargs)
            assert result is not None
"""

# Template for testing HTTP APIs (Integration Tests) - Pytest (Function Based)
# This template uses compiled fixtures - NO LLM enhancement needed
API_TEST_TEMPLATE = """
import pytest
import requests
import uuid
import re

BASE_URL = "{{ base_url }}"
ENDPOINT = "{{ path }}"
METHOD = "{{ method }}"

# Operation: {{ operation_id }}
# Error Codes Expected: {{ error_codes | join(', ') }}
# Auto-generated by TestSuiteGen - Fixtures are pre-compiled


@pytest.fixture(scope="module")
def api_client():
    '''Provides a configured API client for testing.'''
    session = requests.Session()
    session.headers.update({"Content-Type": "application/json"})
    yield session
    session.close()


{{ compiled_fixture }}


@pytest.mark.parametrize("intent, payload, path_params, expected_status", [{%- for case in test_cases %}
    pytest.param(
        "{{ case.intent }}",
        {{ case.payload_formatted }},
        {{ case.path_params_formatted }},
        {{ case.expected_status }},
        id="{{ case.intent }}"
    ),
{%- endfor %}
])
def test_{{ operation_id }}_contract(api_client, test_data_setup, intent, payload, path_params, expected_status):    
    \"\"\"
    Validates {{ method }} {{ path }} against the OpenAPI contract.
    Intent: {{"{intent}"}}
    Expected Status: {{"{expected_status}"}}
    
    {% if error_info %}
    Error Response Information:
    {%- for error in error_info %}
    - Status {{ error.status }}: {{ error.description }}
      {%- if error.schema %}
      Response Schema: {{ error.schema_summary }}
      {%- endif %}
    {%- endfor %}
    {% endif %}
    \"\"\"
    url = f"{BASE_URL}{ENDPOINT}"
    created_resources = test_data_setup.get("created_resources", [])

{{ placeholder_resolution }}

    {% raw %}# Replace path parameters in URL
    for param_name in re.findall(r'\{(\w+)\}', url):
        param_value = path_params.get(param_name)
        # Handle INVALID_TYPE for path parameters
        if param_value == "__INVALID_TYPE__":
            param_value = "invalid_string_value"
        # Fallback to a dummy value if still None
        if param_value is None:
            param_value = 1
        url = url.replace(f"{{{param_name}}}", str(param_value))
    
    # Extract query parameters from payload
    query_params = {}
    if payload and METHOD in ("GET", "DELETE"):
        # For GET/DELETE, move payload to query params
        query_params = payload.copy()
        payload = None
    
    # Generate unique data for creation tests to avoid conflicts
    if METHOD in ("POST", "PUT", "PATCH") and payload and intent == "HAPPY_PATH":
        if "username" in payload:
            payload["username"] = f"{payload['username']}_{uuid.uuid4().hex[:8]}"
        if "email" in payload:
            email_val = payload["email"]
            if "@" in str(email_val):
                email_parts = email_val.split("@")
                payload["email"] = f"{email_parts[0][:10]}_{uuid.uuid4().hex[:6]}@{email_parts[1]}"
    {% endraw %}
    
    response = api_client.request(
        method=METHOD,
        url=url,
        json=payload if payload else None,
        {% raw %}params=query_params if query_params else None,{% endraw %}
        headers={"Content-Type": "application/json"}
    )
    
    {% raw %}assert response.status_code == expected_status, \
        f"Failed Intent: {intent}. Expected {expected_status}, got {response.status_code}. Body: {response.text}"
    
    # Store created resource for cleanup if this is a creation test
    if response.status_code in (200, 201) and METHOD == "POST":
        try:
            resource_data = response.json()
            if isinstance(resource_data, dict):
                res_id = resource_data.get("id")
                if res_id:
                    # Append to the list defined in the fixture (lists are mutable)
                    created_resources.append({
                        "type": "test_resource",
                        "id": res_id,
                        "endpoint": f"{url}/{res_id}"
                    })
        except Exception:
            pass
    {% endraw %}
    
    # Validate error response structure if applicable
    if expected_status >= 400 and response.content:
        try:
            error_body = response.json()
            assert error_body is not None, "Error response should have a JSON body"
            # Additional validation can be added here based on error schema
        except ValueError:
            # Some error responses might not have JSON body
            pass

"""
# Template for testing HTTP APIs (Integration Tests) - Jest
# NOTE: This template intentionally avoids TypeScript-only syntax so it can run
# under a plain Jest setup without ts-jest/babel TypeScript presets.
OPENAPI_JEST_TEST_TEMPLATE = """
// Uses native fetch (Node.js 18+)
// Auto-generated by TestSuiteGen - Setup is pre-compiled

describe("{{ method }} {{ path }} ({{ operation_id }})", () => {
  const BASE_URL = "{{ base_url }}";
  const ENDPOINT = "{{ path }}";
  const METHOD: string = "{{ method }}";  // Typed as string to allow runtime comparisons

  // Operation: {{ operation_id }}
  // Error Codes Expected: {{ error_codes | join(', ') }}

  // Resource tracking for setup/teardown
  const createdResources: Array<{ type: string; id: any; endpoint: string }> = [];
  const placeholders: Record<string, any> = {};

  {% if needs_setup %}
  beforeAll(async () => {
{{ jest_setup_code }}
  });

  afterAll(async () => {
{{ jest_teardown_code }}
  });
  {% endif %}

  const testCases = [
  {% for case in test_cases %}
    {
      intent: "{{ case.intent }}",
      payload: {{ case.payload | tojson }},
      pathParams: {{ case.path_params | tojson if case.path_params else '{}' }},
      expectedStatus: {{ case.expected_status }},
    },
  {% endfor %}
  ];

  it.each(testCases)("intent: %s", async (testCase) => {
    const { intent, payload, pathParams, expectedStatus } = testCase;

    let url = `${BASE_URL}${ENDPOINT}`;

    // Resolve USE_CREATED_RESOURCE placeholders
    // Use Record<string, any> to allow dynamic index access
    const resolvedParams: Record<string, any> = { ...pathParams };
    for (const [name, value] of Object.entries(resolvedParams)) {
      if (typeof value === "string" && value.startsWith("USE_CREATED_RESOURCE")) {
        const resolved = placeholders[value] ?? (createdResources[0]?.id ?? null);
        if (resolved === null) {
          console.warn(`Skipping test: placeholder ${value} not resolved`);
          return; // Skip this test
        }
        resolvedParams[name] = resolved;
      }
    }

    // Replace path parameters in URL
    for (const [name, value] of Object.entries(resolvedParams)) {
      const paramValue =
        value === "__INVALID_TYPE__" ? "invalid_string_value" : value ?? 1;
      url = url.replace(`:${name}`, String(paramValue)).replace(
        `{${name}}`,
        String(paramValue),
      );
    }

    const init: RequestInit = {
      method: METHOD,
      headers: { "Content-Type": "application/json" },
    };

    // Only attach body for methods that support it
    if (payload && ["POST", "PUT", "PATCH"].includes(METHOD)) {
      init.body = JSON.stringify(payload);
    }

    const response = await fetch(url, init);

    expect(response.status).toBe(
      expectedStatus,
    );

    if (expectedStatus >= 400) {
      try {
        const body = await response.json();
        expect(body).toBeDefined();
      } catch {
        // Some error responses might not have JSON body
      }
    }
  });
});

export {};
"""

# Template for testing TypeScript functions (Jest)
TYPESCRIPT_FUNCTION_TEST_TEMPLATE = """
import { {{ function_name }} } from "{{ module_path }}";

// Auto-generated by TestSuiteGen
// Operation: {{ operation_id }}

const testCases: any[] = [
{% for case in test_cases %}
  {
    intent: "{{ case.intent }}",
    args: {{ case.payload }},
    expectedStatus: {{ case.expected_status }},
  },
{% endfor %}
];

describe("{{ operation_id }}", () => {
  it.each(testCases)("intent: %s", async (testCase: any) => {
    const { intent, args, expectedStatus } = testCase;

    if (expectedStatus >= 400) {
      await expect(async () => {
        // @ts-ignore
        return await ({{ function_name }})(...Object.values(args));
      }).rejects.toThrow();
    } else {
      // @ts-ignore
      const result = await ({{ function_name }})(...Object.values(args));
      expect(result).toBeDefined();
    }
  });
});
"""
