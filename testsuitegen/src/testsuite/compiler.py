"""
Fixture Compiler Module

Compiles setup plans into actual Python fixture code.
This is pure code generation - no LLM involved.
"""

from typing import List, Dict, Any
import json

from testsuitegen.src.testsuite.planner import SetupPlan, SetupStep, TeardownStep


class FixtureCompiler:
    """
    Compiles a SetupPlan into executable Python fixture code.

    The generated code is deterministic and complete - no LLM enhancement needed.
    """

    def __init__(self, base_url: str):
        self.base_url = base_url

    def compile(self, plan: SetupPlan) -> str:
        """
        Compile a setup plan into a complete test_data_setup fixture.

        Returns:
            Python code string for the fixture
        """
        if not plan.needs_setup:
            return self._compile_empty_fixture()

        lines = []
        lines.append('@pytest.fixture(scope="module")')
        lines.append("def test_data_setup(api_client):")
        lines.append("    '''")
        lines.append("    Setup fixture that creates prerequisite test resources.")
        lines.append("    Auto-generated by TestSuiteGen - DO NOT EDIT MANUALLY.")
        lines.append("    '''")
        lines.append("    created_resources = []")
        lines.append("    placeholders = {}")
        lines.append("")

        # Generate setup code for each step
        for step in plan.setup_steps:
            lines.extend(self._compile_setup_step(step))
            lines.append("")

        # Yield statement
        lines.append("    yield {")
        lines.append('        "created_resources": created_resources,')
        lines.append('        "placeholders": placeholders,')
        lines.append("    }")
        lines.append("")

        # Teardown
        lines.append("    # Teardown: Clean up created resources in reverse order")
        lines.extend(self._compile_teardown(plan.teardown_steps))

        return "\n".join(lines)

    def _compile_empty_fixture(self) -> str:
        """Generate a minimal fixture when no setup is needed."""
        return '''@pytest.fixture(scope="module")
def test_data_setup(api_client):
    """No prerequisite resources needed for this test."""
    yield {"created_resources": [], "placeholders": {}}'''

    def _compile_setup_step(self, step: SetupStep) -> List[str]:
        """Compile a single setup step into Python code."""
        lines = []

        # Serialize payload
        payload_str = json.dumps(step.payload, indent=8)

        lines.append(f"    # Create {step.resource_type} resource")
        lines.append(f"    {step.variable_name}_payload = {payload_str}")
        lines.append("")
        lines.append(f"    # Make unique to avoid conflicts on repeated runs")
        lines.append(f"    import uuid as _uuid")
        lines.append(f"    _unique_suffix = _uuid.uuid4().hex[:8]")
        lines.append(f"    for _key in {step.variable_name}_payload:")
        lines.append(f"        if isinstance({step.variable_name}_payload[_key], str):")
        lines.append(f"            if 'email' in _key.lower():")
        lines.append(
            f"                parts = {step.variable_name}_payload[_key].split('@')"
        )
        lines.append(f"                if len(parts) == 2:")
        lines.append(
            f'                    {step.variable_name}_payload[_key] = f"{{parts[0]}}_{{_unique_suffix}}@{{parts[1]}}"'
        )
        lines.append(f"            elif 'name' in _key.lower():")
        lines.append(
            f'                {step.variable_name}_payload[_key] = f"{{{step.variable_name}_payload[_key]}}_{{_unique_suffix}}"'
        )
        lines.append("")
        lines.append(f"    {step.variable_name}_response = api_client.post(")
        lines.append(f'        f"{{BASE_URL}}{step.endpoint}",')
        lines.append(f"        json={step.variable_name}_payload")
        lines.append(f"    )")
        lines.append("")
        lines.append(f"    if {step.variable_name}_response.status_code in (200, 201):")
        lines.append(
            f"        {step.variable_name}_data = {step.variable_name}_response.json()"
        )
        lines.append(
            f"        {step.variable_name}_id = {step.variable_name}_data.get('id')"
        )
        lines.append(f"        if {step.variable_name}_id:")
        lines.append(f"            created_resources.append({{")
        lines.append(f"                'type': '{step.resource_type}',")
        lines.append(f"                'id': {step.variable_name}_id,")
        lines.append(f"                'data': {step.variable_name}_data,")
        lines.append(
            f"                'endpoint': f\"{{BASE_URL}}{step.endpoint}/{{{step.variable_name}_id}}\""
        )
        lines.append(f"            }})")
        lines.append(f"            # Map placeholder to created ID")
        lines.append(
            f"            placeholders['USE_CREATED_RESOURCE'] = {step.variable_name}_id"
        )
        lines.append(
            f"            placeholders['USE_CREATED_RESOURCE_{step.resource_type.upper()}'] = {step.variable_name}_id"
        )
        lines.append(f"    else:")
        lines.append(
            f"        # Creation failed - tests needing this resource will be skipped"
        )
        lines.append(
            f'        print(f"Warning: Could not create {step.resource_type}: {{{step.variable_name}_response.status_code}} - {{{step.variable_name}_response.text}}")'
        )

        return lines

    def _compile_teardown(self, teardown_steps: List[TeardownStep]) -> List[str]:
        """Compile teardown steps into Python code."""
        lines = []

        lines.append("    for resource in reversed(created_resources):")
        lines.append("        try:")
        lines.append(
            "            delete_response = api_client.delete(resource['endpoint'])"
        )
        lines.append(
            "            if delete_response.status_code not in (200, 204, 404):"
        )
        lines.append(
            "                print(f\"Cleanup warning: {delete_response.status_code} deleting {resource['type']} {resource['id']}\")"
        )
        lines.append("        except Exception as e:")
        lines.append(
            "            print(f\"Cleanup error: Could not delete {resource['type']} {resource['id']}: {e}\")"
        )

        return lines

    def compile_placeholder_resolution(self) -> str:
        """
        Generate Python code to resolve USE_CREATED_RESOURCE placeholders in tests.
        This code is inserted into the test function body.
        """
        return """    # Resolve USE_CREATED_RESOURCE placeholders to actual IDs
    placeholders = test_data_setup.get("placeholders", {})
    if path_params is None:
        path_params = {}
    if not isinstance(path_params, dict):
        path_params = dict(path_params)
    
    for param_key, param_val in list(path_params.items()):
        if isinstance(param_val, str) and param_val.startswith("USE_CREATED_RESOURCE"):
            resolved_id = placeholders.get(param_val)
            if resolved_id is None and test_data_setup.get("created_resources"):
                resolved_id = test_data_setup["created_resources"][0].get("id")
            if resolved_id is None:
                pytest.skip(f"Required resource placeholder '{param_val}' was not resolved - resource creation may have failed")
            path_params[param_key] = resolved_id"""
