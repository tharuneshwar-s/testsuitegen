ENHANCE_IR_PROMPT_TS = """

You are an expert Semantic Analyzer for Typescript code and JSON Schema generation.
Your task is to enrich and correct a "Basic JSON Schema" based on the provided "Typescript Source Code".

INPUTS:
1. Typescript Code (Function Source)
2. Basic JSON Schema (Generated by a fast AST Parser)
3. Type Definitions (Extracted from parser)

Function Name: {function_name}

The Basic Schema contains placeholders for complex types it could not resolve (e.g., `{"type": "object", "description": "Complex type: User"}`) and lacks semantic constraints.

=====================================
TASK:
=====================================

1. **Resolve Complex Types & Recursion:**
   - Locate classes (Pydantic Models, Dataclasses, TypedDict) defined in the source code AND the provided "Type Definitions".
   - Replace placeholders like `{"description": "Complex type: ClassName"}` with the full schema of that class.
   - **IMPORTANT:** Always add `"x-class-type": "ClassName"` to preserve the original type name.
   - **Crucial:** If a field is a container of complex types (e.g., `List[User]`, `Dict[str, Config]`), you must recursively expand the schema inside the `items` (for List) or `additionalProperties` (for Dict) fields.

2. **Resolve Enums:**
   - Locate `Enum` definitions in the code.
   - Replace placeholders with `{"type": "string", "enum": ["VAL1", "VAL2"], "x-enum-type": "EnumName", "description": "Enum: EnumName"}`.
   - **CRITICAL:** Always include `"x-enum-type": "EnumName"` to preserve the original Enum type name for display purposes.

3. **Handle Return Types:**
   - Check the function's return annotation. If the schema has a "return" or "response" key that is a complex type or placeholder, resolve it using the same logic as input parameters.

4. **Extract Constraints:**
   - **Pydantic/Dataclasses:** Look for `Field(min_length=5, max_length=10)`, `gt=0`, `lt=100`, `regex="..."`. Map these to `minLength`, `maxLength`, `minimum`, `maximum`, and `pattern` respectively.
   - **Typing:** Look for `typing.Annotated` constraints.
   - **Logic/Docstrings:** If explicit type constraints are missing, infer them from validation logic.
     - `if count % 5 != 0:` -> Add `"multipleOf": 5` to the schema.
     - `if x < 10:` -> Add `"maximum": 9` (int) or `"exclusiveMaximum": 10`.
     - `if not x.startswith(...):` -> Add `"pattern": "^..."`.
   - **Arithmetic:** specificially look for `%` modulo checks and map to `multipleOf`.
   - **Internal Whitelists:** Check for lists defined inside the function used for validation (e.g., `allowed_actions = ["list", "show"]`). Add these as `"enum": [...]` to the schema.
   - **Validation Checks:**
     - `if not table.isalnum():` -> Add `"pattern": "^[a-zA-Z0-9]+$"` and description "Alphanumeric only".
     - `dangerous_patterns = [...]` -> Description should note "Disallowed patterns: ...".
   - **Dictionary Keys:**
     - If a Dict argument has its keys checked (e.g., `if "name" not in profile` or `required = ["name", "email"]` loop), convert the `additionalProperties` schema to a fixed `properties` object with those keys marked as `required`.
   - **Graceful Handling:**
     - If the code checks a condition but returns a default value instead of raising an Error (e.g., `if not x: return "default"`), **DO NOT** add a `minLength` or `required` constraint that would force a test failure. Instead, add a description: "Empty input handled gracefully".

5. **Handle Unions and Optionals:**
   - If a type is `Optional[X]` or `X | None`, set the type as the resolved type of X and add `"nullable": true` (or use `anyOf` if strictly following JSON Schema Draft 7, but `nullable` is preferred for simplicity here).
   - If a type is `Union[A, B]`, generate an `anyOf` array containing resolved schemas for A and B.

6. **Extract Decorators:**
   - Inspect the target function definition {function_name}.
   - If decorators exist (e.g., `@auth_required`, `@router.get("/api")`), extract them.
   - **Add to Root:** Add a `"metadata": {"decorators": ["@name1(args)", ...]}` field at the ROOT level of the JSON output. Include arguments if present.

7. **Fallback for Missing Definitions:**
   - If a type is referenced in the signature but its definition is NOT found in the provided code snippet, **DO NOT** invent fields. Keep the original description or mark it as `{"type": "object", "description": "External type: TypeName"}`.

=====================================
RULES:
=====================================
- **DO NOT** remove existing properties found by the AST parser.
- **DO NOT** change the type of primitive fields (int, float, str, bool) unless the AST marked them as "Any".
- **PRESERVE** the structure of the AST schema (properties, required list) while enriching leaf nodes.
- **ENSURE** valid JSON Schema syntax for all resolved types.

=====================================
EXAMPLES:
=====================================

Input Schema:
```json
{
  "type": "object",
  "properties": {
    "status": {"type": "object", "description": "Complex type: OrderStatus"},
    "items": {"type": "array", "items": {"type": "object", "description": "Complex type: Product"}},
    "user": {"type": "object", "description": "Complex type: UserContext"}
  },
  "required": ["status"]
}
```

Code contains:
```Typescript
class OrderStatus(Enum):
    PENDING = "pending"
    SHIPPED = "shipped"

@dataclass
class Product:
    id: int
    name: Annotated[str, Field(min_length=3)]

@dataclass
class UserContext:
    user_id: str

@auth_required(role="admin")
def process_order(status: OrderStatus, items: List[Product], user: UserContext) -> bool:
    ...
```

Expected Output:
```json
{
  "type": "object",
  "properties": {
    "status": {
      "type": "string",
      "enum": ["pending", "shipped"],
      "x-enum-type": "OrderStatus",
      "description": "Enum: OrderStatus"
    },
    "items": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "id": {"type": "integer"},
          "name": {"type": "string", "minLength": 3}
        },
        "required": ["id", "name"],
        "x-class-type": "Product",
        "description": "Class: Product"
      }
    },
    "user": {
      "type": "object",
      "properties": {
        "user_id": {"type": "string"}
      },
      "required": ["user_id"],
      "x-class-type": "UserContext",
      "description": "Class: UserContext"
    }
  },
  "required": ["status"],
  "metadata": {
    "decorators": ["@auth_required(role='admin')"]
  }
}
```

=====================================
EXECUTION
=====================================
# Typescript Code:
{code}

# Type Definitions:
{types}

# Current Schema (AST):
{schema}

Return ONLY the updated JSON Schema as valid JSON.
NO explanations. NO markdown code blocks (```json). NO additional text.
Just the raw JSON object.
"""
